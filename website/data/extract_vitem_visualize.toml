name = "extract_vitem_visualize"
code = """
```rust
use log::LevelFilter;\r
use std::f64::consts::PI;\r
\r
use ranim::{\r
    animation::{creation::WritingAnim, fading::FadingAnim, transform::TransformAnim},\r
    color::palettes::manim,\r
    components::ScaleHint,\r
    items::{\r
        Group,\r
        vitem::{\r
            VItem,\r
            geometry::{Circle, Square},\r
            svg::SvgItem,\r
            typst::typst_svg,\r
        },\r
    },\r
    prelude::*,\r
    render::primitives::{Extract, vitem::VItemPrimitive},\r
    timeline::TimeMark,\r
};\r
\r
use glam::DVec3;\r
\r
#[derive(Clone)]\r
pub struct VisualVItem(VItem);\r
\r
impl Interpolatable for VisualVItem {\r
    fn lerp(&self, target: &Self, t: f64) -> Self {\r
        Self(self.0.lerp(&target.0, t))\r
    }\r
}\r
\r
impl Alignable for VisualVItem {\r
    fn is_aligned(&self, other: &Self) -> bool {\r
        self.0.is_aligned(&other.0)\r
    }\r
    fn align_with(&mut self, other: &mut Self) {\r
        self.0.align_with(&mut other.0);\r
    }\r
}\r
\r
impl Partial for VisualVItem {\r
    fn get_partial(&self, range: std::ops::Range<f64>) -> Self {\r
        Self(self.0.get_partial(range))\r
    }\r
    fn get_partial_closed(&self, range: std::ops::Range<f64>) -> Self {\r
        Self(self.0.get_partial_closed(range))\r
    }\r
}\r
\r
impl Opacity for VisualVItem {\r
    fn set_opacity(&mut self, opacity: f32) -> &mut Self {\r
        self.0.set_opacity(opacity);\r
        self\r
    }\r
}\r
\r
impl StrokeColor for VisualVItem {\r
    fn set_stroke_color(&mut self, color: color::AlphaColor<color::Srgb>) -> &mut Self {\r
        self.0.set_stroke_color(color);\r
        self\r
    }\r
    fn set_stroke_opacity(&mut self, opacity: f32) -> &mut Self {\r
        self.0.set_stroke_opacity(opacity);\r
        self\r
    }\r
    fn stroke_color(&self) -> color::AlphaColor<color::Srgb> {\r
        self.0.stroke_color()\r
    }\r
}\r
\r
impl FillColor for VisualVItem {\r
    fn set_fill_color(&mut self, color: color::AlphaColor<color::Srgb>) -> &mut Self {\r
        self.0.set_fill_color(color);\r
        self\r
    }\r
    fn set_fill_opacity(&mut self, opacity: f32) -> &mut Self {\r
        self.0.set_fill_opacity(opacity);\r
        self\r
    }\r
    fn fill_color(&self) -> color::AlphaColor<color::Srgb> {\r
        self.0.fill_color()\r
    }\r
}\r
\r
impl StrokeWidth for VisualVItem {\r
    fn apply_stroke_func(\r
        &mut self,\r
        f: impl for<'a> Fn(&'a mut [ranim::components::width::Width]),\r
    ) -> &mut Self {\r
        self.0.apply_stroke_func(f);\r
        self\r
    }\r
    fn set_stroke_width(&mut self, width: f32) -> &mut Self {\r
        self.0.set_stroke_width(width);\r
        self\r
    }\r
}\r
\r
impl Extract for VisualVItem {\r
    type Target = Vec<VItemPrimitive>;\r
    fn extract(&self) -> Self::Target {\r
        let mut points = Vec::with_capacity(self.0.vpoints.len());\r
\r
        let subpaths = self.0.vpoints.get_subpaths();\r
\r
        subpaths.iter().for_each(|subpath| {\r
            let subpath_len = subpath.len();\r
\r
            subpath.iter().enumerate().for_each(|(idx, p)| {\r
                if idx == subpath_len - 1 && idx % 2 != 0 {\r
                    return;\r
                }\r
                let point = if idx % 2 == 0 {\r
                    Circle::new(0.06).with(|circle| {\r
                        circle\r
                            .set_color(if idx == 0 {\r
                                manim::GREEN_C\r
                            } else if idx / 2 == (subpath_len - 1) / 2 {\r
                                manim::RED_C\r
                            } else {\r
                                manim::BLUE_C\r
                            })\r
                            .set_fill_opacity(0.6);\r
                    })\r
                } else {\r
                    Circle::new(0.04).with(|circle| {\r
                        circle\r
                            .set_color(manim::WHITE)\r
                            .set_stroke_opacity(0.8)\r
                            .set_fill_opacity(0.4);\r
                    })\r
                }\r
                .with(|circle| {\r
                    circle.put_center_on(*p);\r
                });\r
                points.push(point);\r
            });\r
        });\r
        let mut lines = Vec::with_capacity(self.0.vpoints.len());\r
        self.0\r
            .vpoints\r
            .iter()\r
            .step_by(2)\r
            .zip(self.0.vpoints.iter().skip(1).step_by(2))\r
            .zip(self.0.vpoints.iter().skip(2).step_by(2))\r
            .for_each(|((p0, p1), p2)| {\r
                if p0 != p1 {\r
                    lines.extend_from_slice(&[\r
                        VItem::from_vpoints(vec![*p0, (p0 + p1) / 2.0, *p1]),\r
                        VItem::from_vpoints(vec![*p1, (p1 + p2) / 2.0, *p2]),\r
                    ]);\r
                }\r
            });\r
        [self.0.extract()]\r
            .into_iter()\r
            .chain(lines.into_iter().map(|x| {\r
                x.with(|item| {\r
                    item.set_stroke_width(0.015);\r
                })\r
                .extract()\r
            }))\r
            .chain(points.into_iter().map(|x| x.extract()))\r
            .collect()\r
    }\r
}\r
\r
impl Empty for VisualVItem {\r
    fn empty() -> Self {\r
        Self(VItem::empty())\r
    }\r
}\r
\r
// MARK: ranim_text\r
#[scene]\r
#[preview]\r
#[output(dir = "extract_vitem_visualize")]\r
fn ranim_text(r: &mut RanimScene) {\r
    let r_cam = r.insert_and_show(CameraFrame::default());\r
\r
    let text = SvgItem::new(typst_svg("Ranim")).with(|item| {\r
        item.set_fill_color(manim::WHITE)\r
            .set_fill_opacity(0.5)\r
            .scale_to_with_stroke(ScaleHint::PorportionalY(3.6))\r
            .put_center_on(DVec3::ZERO);\r
    });\r
    let _r_texts = Group::<VItem>::from(text)\r
        .into_iter()\r
        .map(VisualVItem)\r
        .map(|item| r.insert_and_show(item))\r
        .collect::<Vec<_>>();\r
    let default_cam = r.timeline(&r_cam).state().clone();\r
    r.timelines_mut().forward(1.0);\r
    r.timeline_mut(&r_cam).play_with(|cam| {\r
        cam.transform(|cam| {\r
            cam.scale = 0.3;\r
            cam.up = DVec3::NEG_X;\r
            cam.pos.shift(DVec3::NEG_X * 6.0);\r
        })\r
    });\r
    r.timelines_mut().forward(1.0);\r
    r.timeline_mut(&r_cam).play_with(|cam| {\r
        cam.transform(|cam| {\r
            cam.pos.shift(DVec3::X * 12.0);\r
        })\r
        .with_duration(7.0)\r
    });\r
    r.timelines_mut().forward(1.0);\r
    r.timeline_mut(&r_cam)\r
        .play_with(|cam| cam.transform_to(default_cam));\r
\r
    // r.timelines_mut().forward(1.0);\r
    r.insert_time_mark(5.0, TimeMark::Capture("preview-ranim_text.png".to_string()));\r
}\r
\r
#[scene(name = "extract_vitem_visualize")]\r
#[preview]\r
#[output(dir = "extract_vitem_visualize")]\r
pub fn hello_ranim(r: &mut RanimScene) {\r
    let _r_cam = r.insert_and_show(CameraFrame::default());\r
\r
    let square = VisualVItem(VItem::from(Square::new(2.0).with(|square| {\r
        square.set_color(manim::BLUE_C);\r
    })));\r
    let r_vitem = r.insert(square);\r
\r
    let circle = VisualVItem(VItem::from(Circle::new(2.0).with(|circle| {\r
        circle\r
            .set_color(manim::GREEN_C)\r
            .rotate(-PI / 4.0 + PI, DVec3::Z);\r
    })));\r
\r
    {\r
        let timeline = r.timeline_mut(&r_vitem);\r
        timeline\r
            .play_with(|item| item.transform_to(circle))\r
            .forward(1.0);\r
        let circle = timeline.state().clone();\r
        timeline\r
            .play_with(|circle| circle.unwrite().with_duration(2.0))\r
            .play(circle.write().with_duration(2.0))\r
            .play_with(|circle| circle.fade_out());\r
    }\r
\r
    r.timelines_mut().sync();\r
    r.insert_time_mark(3.2, TimeMark::Capture("preview-hello_ranim.png".to_string()));\r
}\r
\r
fn main() {\r
    #[cfg(not(target_arch = "wasm32"))]\r
    {\r
        #[cfg(debug_assertions)]\r
        pretty_env_logger::formatted_timed_builder()\r
            .filter(Some("ranim"), LevelFilter::Trace)\r
            .init();\r
        #[cfg(not(debug_assertions))]\r
        pretty_env_logger::formatted_timed_builder()\r
            .filter(Some("ranim"), LevelFilter::Info)\r
            .init();\r
    }\r
\r
    #[cfg(feature = "app")]\r
    preview(hello_ranim_scene);\r
    #[cfg(not(feature = "app"))]\r
    {\r
        render_scene(hello_ranim_scene);\r
        render_scene(ranim_text_scene);\r
    }\r
}\r
```"""
hash = "0bb4b43908bdd4961cf50346459ea1b76aaca2c3"
preview_imgs = ["/examples/extract_vitem_visualize/preview-hello_ranim.png"]
output_files = ["/examples/extract_vitem_visualize/extract_vitem_visualize_1920x1080_60.mp4"]
wasm = true
